Design Pattern 设计模式
===
1. **Singelton 单列模式**

    轮子，造一个汽车通用轮子，任何一个汽车都可以直接拿去用。
    软件项目中，譬如登陆界面，有可能很多页面都会有登陆按钮，最好的方法肯定是创建一个通用的登陆界面供左右登陆入口（按钮）用。还譬如，网页中的header/footer

2. **Simple Factory 简单工厂**

    由一个方法来决定到底要创建哪个类的实例, 而这些实例经常都拥有相同的接口。 这种模式主要用在所实例化的类型在编译期并不能确定，是在执行期决定的情况。 通俗讲，就像饮料自动贩卖机，要农夫山泉还是要哇哈哈取决于你按哪个按钮。

3. **Push-Subscrible 观察者模式**

    这个应该很好理解吧，又叫发布-订阅者模式，就好比你关注了一个微信公众号，你不用频繁的给他发消息说“来点消息”，他就会每天给你推送消息过来。你是订阅者，公众号是发布者。
    再来个例子：你注册了Design pattern这门课，就开始上课，要考试的时候，老师自然会通知你，而不用你隔一段时间就去问“什么时候考试呀”。然后你参加完考试，就回去等消息就好。到时间，就会通知你成绩（虽然需要你自己登陆账号去查）

4. **Adaptor 适配器模式**

    适配器模式的作用很像一个转接口。
    我们国内带过去的笔记本电源是三孔的，不能直接插在泰国的插线板上，这个时候咋办呢？去7-11买个转接头呗，电源插在转接头上就可以愉快使用了。

5. **Proxy 代理模式**

    把对一个对象的访问, 交给另一个代理对象来操作。
    举一个例子, 我在追一个MM想给她送一束花，但是我因为我性格比较腼腆，所以我托付了MM的闺蜜来送。
    上面这个例子不是非常好，至少没看出代理模式有什么大的用处，因为追MM更好的方式是送一台保时捷或者杜卡迪。
    再举个例子，明星每天都要上通告，演电影电视剧，还得拍广告，出席活动等。如果行程安排和商务合作接洽还得自己亲自来，那肯定是没有私生活时间陪老公/老婆做羞羞事的。这个时候，有代理者经纪人就是一个比较好的方案了。（也说不一定好坏，这个得看姓宋还是姓罗）

6. **Bridge 桥接模式**

    桥接模式的作用在于将实现部分和抽象部分分离开来，以便两者可以独立的变化。在实现api的时候， 桥接模式特别有用。
    例子：要过一条河/垮一个峡谷（实现部分），过/跨的桥(抽象部分)。可以独立抽象组合变化。譬如：你是要造一个铁索桥来过一个峡谷， 同样这个铁索桥也可以用于过一条河。一个石拱桥也同样可以用来过一个峡谷或一条河。
    再通俗解释：桥接模式可以让用处（实现）[A,B]和方法（抽象）[1,2]相互独立构造组合。A1，A2，B1，B2.

7. **Facade 外观模式**

    外观模式，是一种相对简单而又无处不在的模式。外观模式提供一个高层接口，这个接口使得客户端或子系统更加方便调用。
    再来一个饮料贩卖机栗子：一个贩卖机是一个容器，容器里面分别有农夫山泉和哇哈哈两个按钮，分别封装了不同的脚本和逻辑，你去买饮料，投个币，想买农夫山泉就按农夫山泉按钮，想买哇哈哈就按哇哈哈的按钮就ok了。

8. **Vistor 访问者模式**

    访问者模式先把一些可复用的行为抽象到一个函数(对象)里，这个函数我们就称为访问者（Visitor）。如果另外一些对象要调用这个函数，只需要把那些对象当作参数传给这个函数。
    通俗讲：一个垃圾处理站就是一个Visitor函数，你可以拿可回收垃圾去处理，也可以拿不可回收垃圾去处理。

9. **Strategy 策略模式**

    策略模式的意义是定义一系列的算法/方法/函数，把它们一个个封装起来，并且使它们可相互替换。
    这个很好理解。栗子又来了：你要从清迈去曼谷，可以坐飞机，坐火车，坐汽车，抑或骑摩托车去。而具体怎么去，每个策略都可以得到相同的结果，但是它们使用了不同的资源。选择策略的依据是费用，时间，使用工具还有每种方式的方便程度。

10. **Template 模板模式**

    模式方法是预先定义一组算法，先把算法的不变部分抽象到父类，再将另外一些可变的步骤延迟到子类去实现。听起来有点像工厂模式(不是前面的简单工厂模式)。
    栗子来：作为一个不怎么虔诚的基督徒，假设这个世界是由上帝用代码构造的。那么上帝创造生命的时候很可能就用到了模版方法模式。
    首先创造了一个模板,所有生物都有“DNA复制，生，老，病，死”这几个过程。子类可以有“胎生”“卵生”等等不同的具体过程细节，但没有哪个子类可以改变不经历这几个过程，DNA复制也是预先定义的算法中不变部分. 所有子类都不能改写它
    再通俗：一个人会依次经历DNA复制，出生，成长，衰老，死亡这几个过程。这些步骤早在出生前就被上帝决定了，我们改变不了。所幸的是，上帝没有安排好生命的所有细节。我们还可以通过不同的出生环境、经历、你爸是谁，来成为与众不同的个体。你没能控制你出生在马云/健林爸爸家，但你还能控制你的努力程度。

11. **Factory Method 工厂模式**

    与模板模式最大的区别是：工厂模式的意图是根据子类的实现最终获得一种对象，去实现一个抽象接口；而模板模式着重于父类对子类的控制；工厂模式着重在于去抽象出子类的共同点，以便新建子类时，共同点部分不用在重复申明而直接一条语句继承就好。
    譬如：一个汽车工厂，A车就是一个抽象出来的原型。工厂想要新研发B和C两部车，而这两部车可能只是C车是硬顶敞篷，B车是软顶敞篷，那最方便的方法肯定直接在A原型车上面改。（A：原型车。B：保时捷Boxster。C：保时捷Cayman）

12. **Mediator 中介者模式**

    中介者对象可以让各个对象之间不需要显示的相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。
    打个比方，军火买卖双方为了安全起见，找了一个信任的中介来进行交易。买家A把钱交给中介D，然后从中介手中得到军火，卖家C把军火卖给中介，然后从中介手中拿回钱。一场交易完毕，A甚至不知道C是一只猴子还是一只猛犸。因为中介的存在，A也未必一定要买C的军火，也可能是E，F，G。
    中介者模式和代理模式有一点点相似。都是第三者对象来连接2个对象的通信。
    代理模式中A必然是知道B的一切，而中介者模式中A,B,C对E,F,G的实现并不关心.而且中介者模式可以连接任意多种对象。
    具体差别，上图！！！

    **代理模式：**
    ![代理模式](http://jbcdn2.b0.upaiyun.com/2012/10/image-4.png)

    **中介者模式：**
    ![中介者模式](http://jbcdn2.b0.upaiyun.com/2012/10/image-5.png)

13. **Iterater 迭代器模式**

    迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该方法中的内部表示。
    这个超级简单好理解。再不懂代码，累加总还是会的吧？
    ```
    /*10累加：1+2=3+3=6+4=10+5=15+6=21+7=28+8=36+9=45+10=55
    * 每次循环的结果,total都在迭代更新，并且继续执行下一次循环迭代
    */
    function add(total,currentValue) {
        return total + currentValue;
    }
    var nums = [1,2,3,4,5,6,7,8,9,10];
    nums.reduce(add);
    ```

14. **Composite 组合模式**

    又叫部分-整体模式，它将所有对象组合成树形结构。使得用户只需要操作最上层的接口，就可以对所有成员做相同的操作。
    (在前端开发中事件绑定经常触及到到这个模式。事件代理/事件委托)
    这个也没什么好说的，很简单。来例子：
    **多米诺骨牌**
    ![组合模式](wKhQr1NPfZmELclPAAAAAP-SsiI637.jpg)
    不管你把多米诺骨牌排列组合成什么样子，好看或不好看。只需要推倒第一张牌，后面的牌就会biubiubiu...跟着执行相同的动作“倒”。比你一张一张重复手动去推倒肯定要效率很多的。

15. **Memento 备忘录模式**

    这个更没什么好解释的。在前端开发中经常用于数据缓存.
    比如一个分页控件, 从服务器获得某一页的数据后可以存入缓存。以后前进/后退/再翻回这一页的时候，可以直接使用缓存里的数据而无需再次请求服务器。即减少http请求，又快捷。
    PS：不晓得学弟网络课上得咋样，http请求是无状态不持续的链接，并且没每次创建连接TCP/IP协议都会有三次握手，快慢还要视网络环境而定（假设你已懂，如果没懂，赶紧去复习！）。又举例啦，你妈给你打电话说很重要的事，如果你没有录音（缓存），讲完电话后你想再听一遍，只有再打一次电话给你妈，这显然是很浪费资源和时间，并且很傻的行为

16. **Chain of responsibility 职责链模式**

    一个对象A向另一个对象B发起请求，如果B不处理或没法处理，可以把请求转给C，如果C也不处理或没法处理，又可以把请求转给D。一直到有一个对象愿意处理这个请求为止。

    客户让老板写个程序。老板肯定不写，然后老板交给了部门经理。部门经理不愿意写，又交给项目经理。项目经理不会写，又交给程序员。最后由码农来完成。
    在这个假设里， 有几条职责链模式的特点。

    + 老板只跟部门经理打交道，部门经理只联系项目经理，项目经理只找码农的麻烦。
    + 如果码农也不写，这个项目将会流产。
    + 客户并不清楚这个程序最后是由谁写出来的。

    前端开发中的事件冒泡就是作为一个职责链来实现的。一个事件在某个节点上被触发，然后向根节点传递， 直到被节点捕获。

17. **Flyweight 享元模式**

    享元模式主要用来减少程序所需的对象个数。
    直接上栗子：一个租车行，虽然有很多顾客对象，但同时租出去的车辆为N，出去经营成本以及维护成本的角度来说，肯定是车行买N辆车就够了。每次有顾客来都租车就是共享的。当同时需求大于N时，再去增买响应需求的数量就ok了。（当然，这是理论最理想状态)。
    再通俗点的例子是图书馆，图书馆有的书，我们每次去借阅就好，没必要浪费资源人手买一本。

18. **State 状态模式**

    状态模式主要可以用于这种场景

    * 一个对象的行为取决于它的状态
    * 一个操作中含有庞大的条件分支语句

    ![状态模式](http://jbcdn2.b0.upaiyun.com/2012/10/image-2.jpg)

    一个角色有走动，攻击，防御，跌倒，跳跃等等多种状态，而这些状态之间既有联系又互相约束。比如跳跃的时候是不能攻击和防御的。跌倒的时候既不能攻击又不能防御，而走动的时候既可以攻击也可以跳跃。
    要完成这样一箩筐逻辑, if else是少不了的. 而且数量无法估计, 嵌套得眼花缭乱。特别是增加/维护一种状态的时候, 可能要从代码的第10行一直改到900行。
    消灭if else，并且使代码更易于维护和管理。就可以引入状态模式，把相应的状态解耦出来独立成不同的状态对象。
    最后来个例子：想了一下，没想到什么具体情况来分辨，哪个时候用条件语句，哪个时候用状态模式。大概就是条件分支太多，嵌套太深太复杂时，就应该考虑设计模式了
    (PS:一个好的软件项目是“高内聚，低耦合”的，如果不记得相关知识，请求复习！)


结：趁印度同事今天在放假过他们的新年排灯节，刚巧学弟提到设计模式。总结复习了一下自己接触到过的设计模式。平时码代码还没太注意，写写才发现，GOF提出的23种设计模式，已接触过大半十之六七。闲暇之余，写写计划，写写总结，还是有好处的。奈何，作为一个程序员，却手残，打字超级慢。我应该是程序员中打字最慢的^_^。
整理复习看过的资料和自己开发经历的理解随便写了写，不确定对与否，如果看了能纠错，it's better！
